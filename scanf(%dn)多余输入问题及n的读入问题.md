## scanf("%d\n")多余输入问题及\n的读入问题

### 前言

原问题是想在输入数字后把缓冲区的\n也读走，以方便后续的字符串输入工作，而这样想要scanf("%d\n")直接读走\n引发的问题引起了我的思考，虽然知道这样做不行，但想要之所以然，于是此博文诞生，问题简化如下。

```c
#include<stdio.h>
int main(void)
{
	int a;
	scanf("%d\n", &a);
	return 0;
}
//比如输入1\n2\n后程序方可结束
```

一个简单的输入问题，本意是输入一个整数按下回车后就结束程序，但实际程序却需要输入数字\n数字\n,第二个数字不一定非得是数字，只要是非空白符即可（空白符：指空格符、制表符、回车符）。为什么会这样呢？

### 原因

其实是因为scanf的格式化控制字符串有个特点，就是除了标准控制串(以%打头的那些)外，写入了什么就会在那个环节上等待输入什么,否则不会正确往下走。你在%d后写了\n,那么，当接收一个整数后就等待输入\n，等着了就往下走。所以第一次那个\n是被%d后的\n收走；第二次输入的数字2由于已经没有对应的变量接收了，所以还留在输入缓冲区里。第二次输入的\n被当作输入结束命令启动对应变量接收数据。所以最后a得到的是第一次输入的数据。所以正确的写法应该scanf("%d",&a)后用getchar()读走\n,再进行后续的字符/字符串操作。

空口无凭，代码论证。

![](E:\图片\新建文件夹\屏幕截图 2021-10-25 151800.jpg)

按如上代码进行调试，还是输入1\n2\n来验证。

![](E:\图片\新建文件夹\屏幕截图 2021-10-25 152051.jpg)

可以看出，确实如上述一般，1\n由scanf读走了，虽然scanf是通过第二个\n来结束输入的，但并不会把字符读走，只是检测，所以后续的c读走了2，d读走了\n。

### 补充

除了scanf("%c"),scanf有一个特性——忽略先导的空白符，只要他们连续的出现在缓冲区的开头，不管有多少个连续的空白符，scanf都会把其读走并丢弃，直到遇到非空白符，再读入有意义的字符。

读取字符串的时候，比如读aaa\n，你读入字符串最后会带有\n，这个\n并不是你输入的\n，而是编译器自己添加的，你自己输入的\n还留在缓冲区中。