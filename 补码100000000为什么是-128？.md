# 补码100000000为什么是-128？

## 前言：

​	大家知道计算机底层都是通过**补码**做的运算，而无论表面是加减乘除还是其他一些运算，**底层做的都是加法**。原因就不详细展开了，主要是因为这样计算机的运算设计更加简单，而且一切的运算都可以以加法运算为基础。

## 原，反，补

- 正数原码，反码，补码相同，而负数的补码是在原码**保留最高位符号1**位同时对**其余各位取反**再**+1**而得，即补码取反加一。
- 而负数的补码求原码，则是求补码的补码，**补码取反加一**，即符号位不动，其余各位取反后再+1。（或补码减一取反）

问题:char a=127，那你知道a+1的值是多少吗？ 

```cpp
#include<iostream>
using namespace std;

int main()
{
	char a=0b00000000;	//对补码进行操作，不断加1.
	while(1) 
	{
		cout<<(int)a<<" "; 
		a++;
	}	
}
```

在这里你可以看到完整的char类型所能表示的所有大小,以及二进制递增所表示的值的规律。

![](E:\c语言截图\屏幕截图 2021-09-11 120441.png)

## -128的表示

- 实际上计算机用反码来计算，大部分真值的结果是正确的，唯一的问题就是“0”这个特殊的数值上，虽然人们对+0和-0是的理解一样，但是0带符号是没有任何意义的. 而且会有[0000 0000]（原）和[1000 0000]（原）两个编码表示0。

- 于是补码的出现解决了这个问题。这样0就用[0000 0000]来表示，并且用[1000 0000]来表示-128。
- (-1)+(-127)=[1000 0001]（原）+[1111 1111]（原）=[1111 1111]（补）+[1000 0001]（补）=[1000 0000]（补）
- (-1)+(-127)的结果应该是-128, 在用补码运算的结果中, [1000 0000]（补） 就是-128， 但是注意因为实际上是使用之前所谓的“-0”来表示-128, 所以-128并没有原码和反码表示。
- 你可以对-128的补码[1000 0000]（补）来算它的原码，算出来的原码是[0000 0000]（原）, 这显然是错误的。

综上，你就可以理解了为什么基本的有符号的数据类型的大小范围都是是[-n,n-1];

![](E:\c语言截图\屏幕截图 2021-09-11 125834.png)

其他类型基本数据类型道理类似。

