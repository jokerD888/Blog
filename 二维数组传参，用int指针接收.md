# 二维数组传参，用int*接收

## 前言

```c
//我们直到二维数组的数组名是一个地址，等于arr[0][0],即通过值来看，arr=&arr[0][0]
//而下方的Print函数调用，传递的参数却是&arr[0][0],疑问来了,直接传数组名可以吗？（一维数组可以）
#include<stdio.h>
void Print(int* arr) {
	for (int i = 0; i < 10; i++) {
		for (int j = 0; j < 10; j++) {
			printf("%d ", *(arr + i * 10 + j));
		}
	}
}
int main(void)
{
	int arr[10][10];
	int n = 0;
	for (int i = 0; i < 10; i++) {
		for (int j = 0; j < 10; j++) {
			arr[i][j] = ++n;
		}
	}
	Print(&arr[0][0]);	//注意传参方式
	return 0;
}
```

## 原因

- 通过下面的代码来解剖二维数组名和取地址首元素的区别

```c
//现来通过以下代码解剖arr和&arr[0][0]
#include<stdio.h>
int main(void)
{
	int arr[10][10];
	printf("arr的值为：       %d\n", arr);		//十进制输出，方便观察
	printf("&arr[0][0]的值为：%d\n", &arr[0][0]);
	printf("-----------------------------------------------\n");
	printf("arr+1的值为：       %d\n", arr+1);
	printf("&arr[0][0]+1的值为：%d\n", &arr[0][0]+1);
	return 0;
}
//输出结果：
//arr的值为：       8190080
//&arr[0][0]的值为：8190080
//-----------------------------------------------
//arr+1的值为：       8190120
//&arr[0][0]+1的值为：8190084

//可以看出arr和&arr[0][0]的值确实一致
//但各自+1的值却大不相同，arr+1多了40，&arr[0][0]+1多了4，其实和指针步长有关


```

- 二维数组名arr不用说肯定是一个指针，我们知道一维数组名是一个指向首元素的指针，我们是通过指针步长来判断的（即：指针进行+1所跳过的字节数）那么二维数组名的步长是多少呢？

- 通过上方的输出可以看出，arr数组的数组名步长为40，取首元素的地址步长为4，这其实和其各种的类型有关

- ```c
  // &arr[0][0]类型为 int*
  // arr 类型为 int(*)[10]
  ```

- 自此我们可以得知，要想遍历数组，每次+1只能走4个字节即步长为4，如果非要用数组名传参可以这样

- ```c
  Print((int*)arr);
  ```

  

如有错误或遗漏，欢迎指出！